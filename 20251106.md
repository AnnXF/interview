# 内推go并发问题

- **内推远程 挂了（浪）**
- **此时在悉尼 20251106 1158**

### 题1

- map记录出现次数，通过原有数组避免记录出现的索引循序
- 并发合并map需要加锁，通过细粒度的map减少加锁

```go
// Write a function that takes a slice of strings and returns the first string that appears only once. Use goroutines to process the strings concurrently.
// Example Input:
// ["apple", "banana", "apple", "cherry", "banana", "date"]
// Expected Output:
// "cherry"


func FindFirstUniqStr(words []string) string{

	if len(words) == 0 {
			return ""
		}

	// 用于统计词频的 map
	freq := make(map[string]int)
	var mu sync.Mutex
	var wg sync.WaitGroup

	// 并发数量（可以根据长度或CPU数动态调整）
	// 向上取整的公式（a + b -1）/ b 因为 a = kb + r 而 1<= r < b
	workerCount := 3
	chunkSize := (len(words) + workerCount - 1) / workerCount

	for i := 0; i < workerCount; i++ {

		start := i * chunkSize
		if start >= len(words) { // ✅ 防止越界
			break
		}
		end := start + chunkSize
		if end > len(words) {
			end = len(words)
		}

		wg.Add(1)
		go func(sub []string) {

			defer wg.Done()

			// 细粒度map避免频繁锁
			localCount := make(map[string]int)
			for _, w := range sub {
				localCount[w]++
			}

			// 合并map
			mu.Lock()
			defer mu.Unlock()
			for k, v := range localCount {
				freq[k] += v
			}

		}(words[start:end])
	}

	wg.Wait()

	// 按原顺序找第一个只出现一次的
	for _, w := range words {
		if freq[w] == 1 {
			return w
		}
	}
	return ""
}

```


### 题2

- 并发计算的时候记录索引，方便直接修改

```go
// Write a function that takes a slice of integers and returns a new slice with each number squared.
// Use goroutines to perform the squaring concurrently.

// Example Input:
// [1, 2, 3, 4]

// Expected Output:
// [1, 4, 9, 16]

func GoCalc(data []int) []int {

	// 记录计算后的值和原来索引的位置
	type Item struct {
		i int
		v int
	}

	res := make([]int, len(data))
	var wg sync.WaitGroup

	chanItems := make(chan Item, len(data))
	workerCount := 3
	chunkSize := (len(data) + workerCount - 1) / workerCount

	for i := 0; i < workerCount; i++ {
		start := i * chunkSize
		if start >= len(data) { // ✅ 防止越界
			break
		}
		end := start + chunkSize
		if end > len(data) {
			end = len(data)
		}

		wg.Add(1)
		go func(start int, sub []int) {
			defer wg.Done()
			for ind, v := range sub {
				chanItems <- Item{
					i: start + ind,
					v: v * v,
				}
			}
		}(start, data[start:end])
	}

	wg.Wait()
	close(chanItems)

	for resItem := range chanItems {
		res[resItem.i] = resItem.v
	}

	return res
}

```